create type "public"."session_status" as enum ('created', 'active', 'done');

drop policy "Enable insert for public" on "public"."waitlist";

alter table "public"."waitlist" drop constraint "email_unique";

alter table "public"."waitlist" drop constraint "waitlist_pk";

drop index if exists "public"."email_unique";

drop index if exists "public"."waitlist_pk";

drop table "public"."waitlist";

create table "public"."moment" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "session_id" bigint not null,
    "uid" uuid not null,
    "response" text not null,
    "step_id" bigint not null,
    "messages" jsonb not null
);


alter table "public"."moment" enable row level security;

create table "public"."service" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "content" text
);


alter table "public"."service" enable row level security;

create table "public"."session" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "healer_id" bigint not null default '1'::bigint,
    "uid" uuid not null default auth.uid(),
    "step_id" bigint,
    "service_id" bigint not null default '1'::bigint,
    "status" session_status not null default 'created'::session_status
);


alter table "public"."session" enable row level security;

create table "public"."step" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "prior_id" bigint,
    "content" text,
    "name" text
);


alter table "public"."step" enable row level security;

alter table "public"."healer" enable row level security;

drop extension if exists "citext";

CREATE UNIQUE INDEX moment_pkey ON public.moment USING btree (id);

CREATE UNIQUE INDEX service_pkey ON public.service USING btree (id);

CREATE UNIQUE INDEX session_pkey ON public.session USING btree (id);

CREATE UNIQUE INDEX step_pkey ON public.step USING btree (id);

alter table "public"."moment" add constraint "moment_pkey" PRIMARY KEY using index "moment_pkey";

alter table "public"."service" add constraint "service_pkey" PRIMARY KEY using index "service_pkey";

alter table "public"."session" add constraint "session_pkey" PRIMARY KEY using index "session_pkey";

alter table "public"."step" add constraint "step_pkey" PRIMARY KEY using index "step_pkey";

alter table "public"."moment" add constraint "moment_session_id_fkey" FOREIGN KEY (session_id) REFERENCES session(id) not valid;

alter table "public"."moment" validate constraint "moment_session_id_fkey";

alter table "public"."moment" add constraint "moment_step_id_fkey" FOREIGN KEY (step_id) REFERENCES step(id) not valid;

alter table "public"."moment" validate constraint "moment_step_id_fkey";

alter table "public"."moment" add constraint "moment_uid_fkey" FOREIGN KEY (uid) REFERENCES auth.users(id) not valid;

alter table "public"."moment" validate constraint "moment_uid_fkey";

alter table "public"."session" add constraint "session_healer_id_fkey" FOREIGN KEY (healer_id) REFERENCES healer(id) not valid;

alter table "public"."session" validate constraint "session_healer_id_fkey";

alter table "public"."session" add constraint "session_service_id_fkey" FOREIGN KEY (service_id) REFERENCES service(id) not valid;

alter table "public"."session" validate constraint "session_service_id_fkey";

alter table "public"."session" add constraint "session_step_id_fkey" FOREIGN KEY (step_id) REFERENCES step(id) not valid;

alter table "public"."session" validate constraint "session_step_id_fkey";

alter table "public"."session" add constraint "session_uid_fkey" FOREIGN KEY (uid) REFERENCES auth.users(id) not valid;

alter table "public"."session" validate constraint "session_uid_fkey";

alter table "public"."step" add constraint "step_prior_id_fkey" FOREIGN KEY (prior_id) REFERENCES step(id) not valid;

alter table "public"."step" validate constraint "step_prior_id_fkey";

create or replace view "public"."restored_session" as  SELECT moment.session_id,
    string_agg(moment.response, '\n'::text) AS responses
   FROM moment
  GROUP BY moment.session_id;


create policy "Enable insert for authenticated"
on "public"."session"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable select for authenticated on uid"
on "public"."session"
as permissive
for select
to authenticated
using ((auth.uid() = uid));


create policy "Enable update for authenticated on uid"
on "public"."session"
as permissive
for update
to authenticated
using ((auth.uid() = uid))
with check ((auth.uid() = uid));




